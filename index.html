<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Balanced vs. Random Unbalanced Trees (PyScript)</title>

  <!-- 1) Include the latest PyScript (CSS + JS). -->
  <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
  <script defer src="https://pyscript.net/latest/pyscript.js"></script>

  <!-- 2) Tell PyScript which Python packages to install at runtime. -->
  <py-config>
  packages = [
    "networkx",
    "matplotlib"
  ]
  </py-config>

  <!-- Simple styling (feel free to customize). -->
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    h1, h2, h3 {
      text-align: center;
    }
    .slider-container {
      max-width: 500px;
      margin: 0 auto 1em auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .slider-container label {
      margin-right: 0.5em;
    }
    #leaves-slider {
      width: 300px;
      margin-right: 1em;
    }
    #output-area {
      max-width: 900px;
      margin: 0 auto;
      text-align: center;
    }
    img {
      max-width: 90%;
      margin: 0.5em 0;
    }
  </style>
</head>
<body>

<h1>Balanced vs. Random Unbalanced Binary Trees</h1>
<p style="text-align:center;">
  This page uses <strong>PyScript</strong> to run Python, NetworkX, and Matplotlib in your browser.
  Each time you move the slider, it draws two trees:
  a <em>balanced</em> binary tree and a <em>random unbalanced</em> binary tree, both with the same number of leaves.
</p>

<div class="slider-container">
  <label for="leaves-slider">Number of Leaves:</label>
  <input 
    id="leaves-slider" 
    type="range" 
    min="1" 
    max="20" 
    step="1" 
    value="4" 
    oninput="updateTrees()" 
  />
  <span id="slider-value">4</span>
</div>

<div id="output-area">
  <!-- The generated plots will appear here. -->
</div>

<!-- 
  The main PyScript code block.
  We define all Python logic (tree generation, plotting, etc.).
  We'll also define a function that returns an HTML string with <img> tags 
  for the two trees, which we then inject into the #output-area div.
-->
<py-script>
import random
import networkx as nx
import matplotlib
import matplotlib.pyplot as plt

# Use a non-interactive backend that allows us to generate PNGs in memory.
matplotlib.use("Agg")

import io
import base64

def calculate_height(tree, root=0):
    """
    Calculates the height of the tree from the given root.
    The 'height' is the maximum shortest-path distance from 'root' to any other node.
    """
    if not tree.nodes:
        return 0
    undirected = tree.to_undirected()
    lengths = nx.shortest_path_length(undirected, source=root)
    return max(lengths.values())

def generate_balanced_tree(num_leaves):
    """
    Generate a 'balanced' binary tree with exactly num_leaves leaves.
    We start with 1 leaf (the root), and repeatedly expand one leaf into two children
    until we have exactly num_leaves leaves.
    """
    if num_leaves < 1:
        return nx.DiGraph()
    if num_leaves == 1:
        # Single node
        tree = nx.DiGraph()
        tree.add_node(0)
        return tree

    tree = nx.DiGraph()
    root = 0
    tree.add_node(root)
    leaves = [root]
    leaves_count = 1
    next_label = 1

    # BFS expansion
    while leaves_count < num_leaves:
        parent = leaves.pop(0)
        left_child = next_label
        right_child = next_label + 1
        tree.add_node(left_child)
        tree.add_node(right_child)
        tree.add_edge(parent, left_child)
        tree.add_edge(parent, right_child)
        leaves_count += 1
        next_label += 2
        leaves.append(left_child)
        leaves.append(right_child)

    return tree

def generate_unbalanced_tree_random(num_leaves):
    """
    Generate an 'unbalanced' binary tree with exactly num_leaves leaves,
    picking a random leaf to expand each time.
    """
    if num_leaves < 1:
        return nx.DiGraph()
    if num_leaves == 1:
        tree = nx.DiGraph()
        tree.add_node(0)
        return tree

    tree = nx.DiGraph()
    root = 0
    tree.add_node(root)
    leaves = [root]
    leaves_count = 1
    next_label = 1

    while leaves_count < num_leaves:
        parent = random.choice(leaves)
        leaves.remove(parent)
        left_child = next_label
        right_child = next_label + 1
        tree.add_node(left_child)
        tree.add_node(right_child)
        tree.add_edge(parent, left_child)
        tree.add_edge(parent, right_child)
        leaves_count += 1
        next_label += 2
        leaves.append(left_child)
        leaves.append(right_child)

    return tree

def get_rooted_positions(tree, root=0):
    """
    Assign each node a 'subset' = distance from root.
    Then use nx.multipartite_layout and swap x,y to get a top-down layout.
    """
    if not tree.nodes:
        return {}
    undirected = tree.to_undirected()
    dist_from_root = nx.shortest_path_length(undirected, source=root)
    for node, dist in dist_from_root.items():
        tree.nodes[node]['subset'] = dist
    pos = nx.multipartite_layout(tree, subset_key='subset', align='vertical', scale=2.0)
    pos_swapped = {node: (y, -x) for node, (x, y) in pos.items()}
    return pos_swapped

def draw_tree(tree, title):
    """
    Return a (fig, png_base64) tuple for the given tree.
    """
    fig, ax = plt.subplots(figsize=(5, 5))
    height = calculate_height(tree, root=0)
    pos = get_rooted_positions(tree, root=0)
    nx.draw(
        tree, pos, with_labels=True, node_size=600, 
        node_color="lightblue", arrows=False, ax=ax
    )
    ax.set_title(f"{title}\nHeight: {height}", fontsize=12)
    ax.axis("off")
    fig.tight_layout()

    # Convert the figure to PNG in base64
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight")
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode("utf-8")
    plt.close(fig)
    return img_b64

def generate_trees_html(num_leaves):
    """
    Generate both the balanced and the random-unbalanced trees as 
    base64-encoded PNG images, return them as <img> tags in an HTML string.
    """
    # Balanced
    balanced = generate_balanced_tree(num_leaves)
    bal_b64 = draw_tree(balanced, f"Balanced (Leaves={num_leaves})")

    # Random Unbalanced
    unbalanced = generate_unbalanced_tree_random(num_leaves)
    unbal_b64 = draw_tree(unbalanced, f"Random Unbalanced (Leaves={num_leaves})")

    # Combine into an HTML snippet
    html = f"""
    <div>
      <img src="data:image/png;base64,{bal_b64}" alt="Balanced Tree" />
    </div>
    <div>
      <img src="data:image/png;base64,{unbal_b64}" alt="Random Unbalanced Tree" />
    </div>
    """
    return html
</py-script>

<!-- 
  Minimal JS that reads the slider value and calls our Python function
  generate_trees_html(...) via pyscript.interpreter.run(...)
-->
<script>
async function updateTrees() {
  const slider = document.getElementById("leaves-slider");
  const value = slider.value;
  document.getElementById("slider-value").innerText = value;

  // We'll run a tiny Python snippet that calls generate_trees_html(value).
  // Then we inject the returned HTML into #output-area.
  const code = `
result = generate_trees_html(${value})
result
  `;
  let result = await pyscript.interpreter.run(code);
  let htmlStr = result.result.toString();  // .toString() to get the actual HTML
  document.getElementById("output-area").innerHTML = htmlStr;
}

// On page load, set up the initial trees
window.addEventListener("DOMContentLoaded", () => {
  updateTrees();
});
</script>

</body>
</html>
