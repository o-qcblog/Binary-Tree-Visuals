<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Balanced vs. Random Unbalanced Trees</title>
    <!-- Load Pyodide (Python in the browser) -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.2/full/pyodide.js"></script>

    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }

      #trees-container {
        display: flex;
        flex-direction: row;
        gap: 40px;
        margin-top: 20px;
      }

      .tree-plot {
        text-align: center;
      }

      .tree-plot img {
        border: 1px solid #ccc;
        margin-top: 10px;
      }

      #slider {
        width: 300px;
      }
    </style>
</head>
<body>
  <h1>Balanced vs. Random Unbalanced Trees</h1>
  <p>
    Select number of leaves:
    <input type="range" id="slider" min="1" max="20" value="4" />
    <span id="slider-value">4</span>
  </p>

  <div id="trees-container">
    <div class="tree-plot">
      <h3 id="title-balanced"></h3>
      <img id="img-balanced" />
    </div>
    <div class="tree-plot">
      <h3 id="title-unbalanced"></h3>
      <img id="img-unbalanced" />
    </div>
  </div>

  <script>
    //
    // Step 1: Load Pyodide and install packages
    //
    async function main() {
      // Load Pyodide
      window.pyodide = await loadPyodide();

      // Install needed packages dynamically: networkx and matplotlib
      // micropip is Pyodideâ€™s PEP 503 package installer
      await pyodide.runPythonAsync(`
import micropip
await micropip.install("networkx")
await micropip.install("matplotlib")
`);

      //
      // Step 2: Define your entire Python code as a string
      //
      const pythonCode = `
import networkx as nx
import matplotlib
# Use the 'Agg' backend (headless) for creating plots in memory
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import random
from io import BytesIO
import base64

def calculate_height(tree, root=0):
    if not tree.nodes:
        return 0
    undirected = tree.to_undirected()
    lengths = nx.shortest_path_length(undirected, source=root)
    return max(lengths.values())

def generate_balanced_tree(num_leaves):
    if num_leaves < 1:
        return nx.DiGraph()
    if num_leaves == 1:
        tree = nx.DiGraph()
        tree.add_node(0)
        return tree

    tree = nx.DiGraph()
    root = 0
    tree.add_node(root)
    leaves = [root]
    leaves_count = 1
    next_label = 1

    while leaves_count < num_leaves:
        parent = leaves.pop(0)
        left_child = next_label
        right_child = next_label + 1
        tree.add_node(left_child)
        tree.add_node(right_child)
        tree.add_edge(parent, left_child)
        tree.add_edge(parent, right_child)
        leaves_count += 1
        next_label += 2
        leaves.append(left_child)
        leaves.append(right_child)

    return tree

def generate_unbalanced_tree_random(num_leaves):
    if num_leaves < 1:
        return nx.DiGraph()
    if num_leaves == 1:
        tree = nx.DiGraph()
        tree.add_node(0)
        return tree

    tree = nx.DiGraph()
    root = 0
    tree.add_node(root)
    leaves = [root]
    leaves_count = 1
    next_label = 1

    while leaves_count < num_leaves:
        parent = random.choice(leaves)
        leaves.remove(parent)
        left_child = next_label
        right_child = next_label + 1
        tree.add_node(left_child)
        tree.add_node(right_child)
        tree.add_edge(parent, left_child)
        tree.add_edge(parent, right_child)
        leaves_count += 1
        next_label += 2
        leaves.append(left_child)
        leaves.append(right_child)

    return tree

def get_rooted_positions(tree, root=0):
    if not tree.nodes:
        return {}
    undirected = tree.to_undirected()
    dist_from_root = nx.shortest_path_length(undirected, source=root)
    for node, dist in dist_from_root.items():
        tree.nodes[node]['subset'] = dist

    pos = nx.multipartite_layout(tree, subset_key='subset', align='vertical', scale=2.0)
    # Swap x,y to get a top-to-bottom layout
    pos_swapped = {node: (y, -x) for node, (x, y) in pos.items()}
    return pos_swapped

def draw_tree(tree, title, root=0):
    height = calculate_height(tree, root=root)
    pos = get_rooted_positions(tree, root=root)
    fig, ax = plt.subplots()
    nx.draw(
        tree, pos, with_labels=True, node_size=600,
        node_color="lightblue", arrows=False, ax=ax
    )
    ax.set_title(f"{title}\\nHeight: {height}", fontsize=12)
    ax.axis("off")

    # Convert the figure to base64 for inline display
    buf = BytesIO()
    fig.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    data = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    return data

def draw_trees(num_leaves):
    balanced_tree = generate_balanced_tree(num_leaves)
    unbalanced_tree = generate_unbalanced_tree_random(num_leaves)

    balanced_img = draw_tree(balanced_tree, f"Balanced (Leaves={num_leaves})")
    unbalanced_img = draw_tree(unbalanced_tree, f"Random Unbalanced (Leaves={num_leaves})")
    return balanced_img, unbalanced_img
`;

      // Load the Python code into Pyodide
      await pyodide.runPythonAsync(pythonCode);

      // Expose a callable function in the global scope so we can call it from JS
      window.drawTrees = async function(num_leaves) {
        // run Python in the global namespace
        let result = await pyodide.runPythonAsync(`
balanced_img, unbalanced_img = draw_trees(${num_leaves})
(balanced_img, unbalanced_img)
`);
        // result is a PyProxy tuple => convert to JS array
        return result.toJs();
      };
    }

    //
    // Step 3: Initialize Pyodide, wire up the slider
    //
    main().then(() => {
      const slider = document.getElementById('slider');
      const sliderValue = document.getElementById('slider-value');
      const titleBalanced = document.getElementById('title-balanced');
      const titleUnbalanced = document.getElementById('title-unbalanced');
      const imgBalanced = document.getElementById('img-balanced');
      const imgUnbalanced = document.getElementById('img-unbalanced');

      async function updateTrees() {
        let leaves = slider.value;
        sliderValue.textContent = leaves;
        // Call the Python function to get new images
        let [balanced_img, unbalanced_img] = await drawTrees(leaves);
        // Update the <img> tags
        imgBalanced.src = "data:image/png;base64," + balanced_img;
        imgUnbalanced.src = "data:image/png;base64," + unbalanced_img;

        titleBalanced.textContent = "Balanced (Leaves=" + leaves + ")";
        titleUnbalanced.textContent = "Random Unbalanced (Leaves=" + leaves + ")";
      }

      // Recompute trees on slider input
      slider.addEventListener('input', updateTrees);

      // Initial draw
      updateTrees();
    });
  </script>
</body>
</html>
