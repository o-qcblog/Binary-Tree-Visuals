<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Trees with PyScript</title>

  <!-- 1) Include the latest PyScript (CSS + JS). -->
  <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
  <script defer src="https://pyscript.net/latest/pyscript.js"></script>

  <!-- 2) Configure which packages PyScript should install at runtime. -->
  <py-config>
  packages = [
    "networkx",
    "matplotlib"
  ]
  </py-config>

  <!-- Some simple styling. Feel free to customize. -->
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
    }
    .slider-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .slider-container input[type="range"] {
      width: 300px;
      margin: 0 1rem;
    }
    .trees-container {
      text-align: center;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Balanced vs. Random Unbalanced Binary Trees</h1>

  <!-- Slider for the number of leaves -->
  <div class="slider-container">
    <label for="leaves-slider">Number of Leaves: </label>
    <input 
      id="leaves-slider" 
      type="range" 
      min="1" max="20" step="1" 
      value="4"
      oninput="updateTrees(this.value)"
    >
    <span id="slider-value">4</span>
  </div>

  <!-- The py-script code block where we define our Python logic. -->
  <py-script>
    import random
    import networkx as nx
    import matplotlib
    import matplotlib.pyplot as plt

    # Use an Agg canvas (non-interactive) so we can render and show in PyScript.
    matplotlib.use("Agg")

    from math import inf
    from pyodide.ffi import to_js

    # --- Original code (slightly adapted) ---

    def calculate_height(tree, root=0):
        """
        Calculates the height of the tree from the given root.
        The 'height' is the maximum shortest-path distance from 'root' to any other node.
        """
        if not tree.nodes:
            return 0
        undirected = tree.to_undirected()
        lengths = nx.shortest_path_length(undirected, source=root)
        return max(lengths.values())

    def generate_balanced_tree(num_leaves):
        """
        Generate a 'balanced' binary tree with exactly num_leaves leaves.
        Start with 1 leaf (root), expand BFS, each expansion adds net +1 leaf.
        """
        if num_leaves < 1:
            return nx.DiGraph()
        if num_leaves == 1:
            tree = nx.DiGraph()
            tree.add_node(0)
            return tree

        tree = nx.DiGraph()
        root = 0
        tree.add_node(root)
        leaves = [root]
        leaves_count = 1
        next_label = 1

        while leaves_count < num_leaves:
            parent = leaves.pop(0)  # BFS: front of the queue
            left_child = next_label
            right_child = next_label + 1

            tree.add_node(left_child)
            tree.add_node(right_child)
            tree.add_edge(parent, left_child)
            tree.add_edge(parent, right_child)

            leaves_count += 1
            next_label += 2

            leaves.append(left_child)
            leaves.append(right_child)

        return tree

    def generate_unbalanced_tree_random(num_leaves):
        """
        Generate an 'unbalanced' binary tree with exactly num_leaves leaves,
        picking a random leaf each time to expand.
        """
        if num_leaves < 1:
            return nx.DiGraph()
        if num_leaves == 1:
            tree = nx.DiGraph()
            tree.add_node(0)
            return tree

        tree = nx.DiGraph()
        root = 0
        tree.add_node(root)
        leaves = [root]
        leaves_count = 1
        next_label = 1

        while leaves_count < num_leaves:
            parent = random.choice(leaves)
            leaves.remove(parent)

            left_child = next_label
            right_child = next_label + 1
            tree.add_node(left_child)
            tree.add_node(right_child)
            tree.add_edge(parent, left_child)
            tree.add_edge(parent, right_child)

            leaves_count += 1
            next_label += 2

            leaves.append(left_child)
            leaves.append(right_child)

        return tree

    def get_rooted_positions(tree, root=0):
        """
        Assign each node a 'subset' = distance from root.
        Then use nx.multipartite_layout and swap x,y.
        """
        if not tree.nodes:
            return {}
        
        undirected = tree.to_undirected()
        dist_from_root = nx.shortest_path_length(undirected, source=root)
        
        for node, dist in dist_from_root.items():
            tree.nodes[node]['subset'] = dist

        pos = nx.multipartite_layout(tree, subset_key='subset', align='vertical', scale=2.0)
        
        # Swap x,y
        pos_swapped = {node: (y, -x) for node, (x, y) in pos.items()}
        return pos_swapped

    def draw_tree(tree, title, root=0):
        """
        Returns a matplotlib Figure containing the drawn tree.
        """
        fig, ax = plt.subplots(figsize=(6, 6))
        height = calculate_height(tree, root=root)
        pos = get_rooted_positions(tree, root=root)

        nx.draw(
            tree, pos, with_labels=True, node_size=600,
            node_color="lightblue", arrows=False, ax=ax
        )
        ax.set_title(f"{title}\nHeight: {height}", fontsize=12)
        ax.axis("off")
        fig.tight_layout()
        return fig

    def generate_trees_html(num_leaves):
        """
        Generate both trees as separate matplotlib figures,
        then return HTML <img> tags (base64-encoded PNGs).
        """
        # Balanced
        balanced_tree = generate_balanced_tree(num_leaves)
        fig_bal = draw_tree(balanced_tree, f"Balanced (Leaves={num_leaves})")
        # Convert fig_bal to PNG in memory
        import io
        buf_bal = io.BytesIO()
        fig_bal.savefig(buf_bal, format="png", bbox_inches="tight")
        buf_bal.seek(0)
        import base64
        png_bal = base64.b64encode(buf_bal.read()).decode("utf-8")
        plt.close(fig_bal)

        # Random Unbalanced
        unbalanced_tree = generate_unbalanced_tree_random(num_leaves)
        fig_unbal = draw_tree(unbalanced_tree, f"Random Unbalanced (Leaves={num_leaves})")
        buf_unbal = io.BytesIO()
        fig_unbal.savefig(buf_unbal, format="png", bbox_inches="tight")
        buf_unbal.seek(0)
        png_unbal = base64.b64encode(buf_unbal.read()).decode("utf-8")
        plt.close(fig_unbal)

        # Return HTML with two images stacked vertically
        html = f"""
        <div class='trees-container'>
            <img src='data:image/png;base64,{png_bal}' alt='Balanced Tree'/>
            <br/>
            <img src='data:image/png;base64,{png_unbal}' alt='Unbalanced Tree'/>
        </div>
        """
        return html

    # Create an initial variable in the PyScript scope for storing results
    # We'll inject the <img> tags into this element by ID in the DOM.
  </py-script>

  <!--
    Where the final tree images will appear.
    Weâ€™ll place them here dynamically from JavaScript calling into PyScript.
  -->
  <div id="trees-output" class="trees-container">
    <!-- The two tree images will be injected here. -->
  </div>

  <!-- Some inline JavaScript to wire up the slider -> PyScript callback. -->
  <script>
    // We'll call this function whenever the slider changes.
    async function updateTrees(value) {
      // Update the label next to the slider
      document.getElementById("slider-value").textContent = value;
      
      // Use PyScript's global 'pyscript' object to call Python from JS
      // We'll call a small snippet of Python that calls `generate_trees_html(value)`.
      // Then we set the HTML of 'trees-output' div to the returned HTML string.
      const code = `
result_html = generate_trees_html(${value})
result_html
      `;
      let result = await pyscript.interpreter.run(code);
      
      // result is a PyProxy object. The actual string is .toString()
      let htmlStr = result.toString();
      document.getElementById("trees-output").innerHTML = htmlStr;
    }

    // On initial load, let's call updateTrees(4) or the default slider value
    window.addEventListener("DOMContentLoaded", () => {
      let slider = document.getElementById("leaves-slider");
      updateTrees(slider.value);
    });
  </script>

</div>
</body>
</html>
